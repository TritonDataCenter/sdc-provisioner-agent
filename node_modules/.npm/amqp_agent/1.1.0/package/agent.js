sys = require('sys');
dns = require('dns');

amqp = require('amqp');
mDNS = require('mdns');
dns = require('dns');
exec = require('child_process').exec;

EventEmitter = require("events").EventEmitter;

inspect = sys.inspect;

exports.timestamp = timestamp = function () { return (new Date).toISOString(); }

exports.AMQPAgent = AMQPAgent = function (config) {
  var self = this;
  EventEmitter.call(this);

  this.config = config = config || { amqp: {} };
  this.commandNames = [];

  // AMQP credentials
  this.config.amqp = this.config.amqp || {};
  this.config.amqp.host
    = config.amqp.host     || process.env['AMQP_HOST']      || 'localhost';
  this.config.amqp.login
    = config.amqp.login    || process.env['AMQP_LOGIN']     || 'guest';
  this.config.amqp.password
    = config.amqp.password || process.env['AMQP_PASSWORD']  || 'guest';
  this.config.amqp.vhost
    = config.amqp.vhost    || process.env['AMQP_VHOST']     || '/';
  this.config.amqp.port
    = config.amqp.port     || process.env['AMQP_PORT']     || 5672;

  // Map the id's of incoming messages to the clients who sent them. This is
  // to avoid spamming all clients with ACKs they don't care about.
  this.messageIdToClientId = {};
  this._done = true;
}

sys.inherits(AMQPAgent, EventEmitter);

AMQPAgent.prototype.lookupUUID = function (callback) {
  var self = this;
  // If the we have a UUID defined in the configuration, use that. Otherwise
  // call sysinfo and retrieve the value from there.

  if (this.config.uuid) {
    self.uuid = self.config.uuid;
    return callback();
  }

  loadSysinfo(function (error, exitStatus, stdout, stderr) {
    if (error) {
      throw (new Error("sysinfo error: " + stderr.toString()));
    }

    // output of sysinfo is a JSON object
    var sysinfo = JSON.parse(stdout);

    // Use the UUID param to uniquely identify this machine on AMQP.
    nodeUUID = sysinfo['UUID'];
    if (!nodeUUID) {
      throw new Error("Could not find 'UUID' in `sysinfo` output.");
    }

    self.uuid = nodeUUID;
    callback && callback();
  });
}

// Run the sysinfo script and return the captured stdout, stderr, and exit
// status code.
function loadSysinfo (callback) {
  execFile
    ( '/usr/bin/sysinfo'
    , []
    , function (exitStatus, stdout, stderr) {
        if (exitStatus)
          return callback(new Error(stderr), exitStatus, stdout, stderr);
       
        callback
          ( undefined
          , exitStatus
          , stdout.toString().trim()
          , stderr.toString().trim()
          );
        return;
      }
    );
} 

AMQPAgent.prototype.connect = function(callback) {
  var self = this;

  self.lookupUUID(function () {
    var cb = function () {
      self.setupQueue(function () {
        callback();
      });
    }

    console.log("Connection details:", inspect(self.config.amqp));
    if (self.config.mdns) {
      self.mDNSConnect(cb);
    }
    else {
      self.connection = amqp.createConnection(self.config.amqp);
      self.addListeners(cb);
    }
  });
}

AMQPAgent.prototype.mDNSConnect = function (callback) {
  var self = this;

  console.log("Looking '" + this.config.mdns + "' service in mDNS.");
  var browser
    = mDNS.createBrowser
        ( this.config.mdns
        , { resolveAddress: false, autoResolve: true }
        );

  receivedResponse = false;
  browser.addListener('serviceUp', function(info) {
    if (receivedResponse) return;
    receivedResponse = true;

    browser.stop();
    console.log('Received mDNS serviceUp event for "' + self.config.mdns + '": ', inspect(info));

    self.config.amqp.port = info['port'];
    dns.lookup(info['host'].replace(/\.$/, ''), function (error, addr) {
      if (error) throw error;
      self.config.amqp.host = addr;
      self.connection = amqp.createConnection(self.config.amqp);
      self.addListeners(callback);
    });
  });
  browser.start();
}

AMQPAgent.prototype.end = function () {
  this.connection.end();
}

AMQPAgent.prototype.addListeners = function (callback) {
  var self = this;

  var once = [callback];
  this.connection.addListener('ready', function () {
    console.log("Ready to receive commands");
    self.exchange = self.connection.exchange('amq.topic', { type: 'topic' });

    // Call callback on first connect, but not on reconnect.
    if (once.length)
      once.pop()();
  });

  this.connection.addListener('error', function (e) {
    console.log("There was an AMQP error: " + e.message);
  });

  this.connection.addListener('close', function () {
    if (self.config.reconnect) {
      console.log('MQ connection severed. Waiting 5 seconds...');
      setTimeout(function () {
        console.log('Connecting...');
        self.connection.reconnect();
      }, 5000);
    }
  });
}

//  Reply to client with an ACK message indicating command success
AMQPAgent.prototype.ackSuccess = function (id, data) {
  this._done = true;
  var msg = { req_id: id
            , timestamp: timestamp()
            };
  if (data && Object.keys(data).length) {
    for (key in data) {
      msg[key] = data[key];
    }
  }

  console.log("Publishing success: " + inspect(msg));
  this.exchange.publish
    ( this.config.resource
      + '.ack'
      + this.messageIdToClientId[id]
      + '.'
      + this.uuid
    , msg
    );

  if (!this.gracefulStop) {
    this.queue.shift();
  }
}

//  Reply to client with an ACK message indicating command error
AMQPAgent.prototype.ackError = function (id, error) {
  this._done = true;
  var msg = { req_id: id
            , timestamp: timestamp()
            , error: error };
  console.log("Publishing error " + inspect(msg));
  this.exchange.publish
    ( this.config.resource
      + '.ack'
      + this.messageIdToClientId[id]
      + '.'
      + this.uuid
    , msg);

  if (!this.gracefulStop) {
    this.queue.shift();
  }
}

AMQPAgent.prototype.stopShifting = function () {
  this.gracefulStop = true;
}

AMQPAgent.prototype.isDone = function () {
  return this._done;
}

AMQPAgent.prototype.handleMessage = function(msg) {
  var self = this;
  if (!msg._routingKey) {
    log('Error: message received without routingKey:\n' + inspect(msg));
    return;
  }

  var command = msg._routingKey.split('.')[1];

  if (this.commandNames.indexOf(command) === -1) {
    var errorMsg = 'Error: message received with invalid command, "'
                   + command + '"';
    self.ackError(msg.id, errorMsg);
    return;
  }

  console.log("--- Message received:\n" + inspect(msg));

  this.messageIdToClientId[msg.id] = msg.client_id;
  this._done = false;
  this.emit('command', command, msg);
}

AMQPAgent.prototype.registerCommand = function (command) {
  this.commandNames.push(command);
}

AMQPAgent.prototype.setupQueue = function(callback) {
  var self = this;
  var queueName = this.queueName = this.config.resource + '.' + this.uuid;
  this.queue = this.connection.queue(queueName, { exclusive: true });

  for (var i = 0, il = this.commandNames.length; i < il; i++) {
    self.queue.bind('amq.topic', this.config.resource + '.' + this.commandNames[i] + '.' + this.uuid);
  }
  this.queue.addListener('open', function (messageCount, consumerCount) {
    self.queue.subscribeJSON({ ack: true }, function (msg) {
      self.handleMessage(msg);
      // We will let ackError/ackSuccess do queue shifting
    });
  });

  callback();
}

