sys = require('sys');

amqp = require('amqp');
dns = require('dns');
exec = require('child_process').exec;

EventEmitter = require("events").EventEmitter;

inspect = sys.inspect;

exports.timestamp = timestamp = function () { return (new Date).toISOString(); }

exports.AMQPAgent = AMQPAgent = function (config) {
  var self = this;
  EventEmitter.call(this);

  this.config = config || { amqp: {} };
  this.commandNames = [];

  // Map the id's of incoming messages to the clients who sent them. This is
  // to avoid spamming all clients with ACKs they don't care about.
  this.messageIdToClientId = {};
  this._done = true;
}

sys.inherits(AMQPAgent, EventEmitter);

// Try to use /usr/bin/sysinfo and /lib/sdc/config.sh to determine AMQP
// credentials or fall back to ENV variables.
AMQPAgent.prototype.configureAMQP = function (callback) {
  var self = this;

  self.config.amqp = self.config.amqp || {};

  if (process.env['AMQP_USE_SYSTEM_CONFIG']) {
    sysinfo(function (error, config) {
      var headnode = config['Boot Parameters'].headnode;
      if (headnode && (headnode === true || headnode === "true")) {
        sdcConfig(function (error, config) {
          var rabbitmq = config['rabbitmq'].split(':');
          if (!rabbitmq) throw new Error("Could not find 'rabbitmq' parameter from /lib/sdc/config.sh");
          setAMQPConfig.apply(undefined, rabbitmq);
          callback();
        });
      }
      else {
        var rabbitmq = config['Boot Parameters'].rabbitmq;
        if (!rabbitmq) throw new Error("Could not find 'Boot Parameters'.'rabbitmq' in sysinfo");
        setAMQPConfig.apply(undefined, rabbitmq);
        callback();
      }
    });
  }
  else {
    setAMQPConfig
      ( self.config.amqp.login    || process.env['AMQP_LOGIN']
      , self.config.amqp.password || process.env['AMQP_PASSWORD']
      , self.config.amqp.host     || process.env['AMQP_HOST']
      , self.config.amqp.port     || process.env['AMQP_PORT']
      , self.config.amqp.vhost    || process.env['AMQP_VHOST']
      );
    callback();
  }

  function setAMQPConfig(login, password, host, port, vhost) {
    self.config.amqp.login    = login      || 'guest';
    self.config.amqp.password = password   || 'guest';
    self.config.amqp.host     = host       || 'localhost';
    self.config.amqp.port     = port       || 5672;
    self.config.amqp.vhost    = vhost      || '/';
  }
}

function execFileParseJSON (bin, args, callback) {
  execFile
    ( bin
    , args
    , function (error, stdout, stderr) {
        if (error)
          return callback(Error(stderr.toString()));
        var obj = JSON.parse(stdout.toString());
        callback(null, obj);
      }
    );
}

function sysinfo (callback) {
  execFileParseJSON
    ( '/usr/bin/sysinfo'
    , []
    , function (error, config) {
        if (error)
          return callback(error);
        callback(null, config);
      }
    );
}

function sdcConfig (callback) {
  execFileParseJSON
    ( '/bin/bash'
    , [ '/lib/sdc/config.sh', '-json' ]
    , function (error, config) {
        if (error)
          return callback(error);
        callback(null, config);
      }
    );
}

AMQPAgent.prototype.lookupUUID = function (callback) {
  var self = this;
  // If the we have a UUID defined in the configuration or an environment
  // variable, use that. Otherwise call sysinfo and retrieve the value from
  // there.

  if (self.config.uuid || process.env['SERVER_UUID']) {
    self.uuid = self.config.uuid || process.env['SERVER_UUID'];
    return callback();
  }

  loadSysinfo(function (error, exitStatus, stdout, stderr) {
    if (error) {
      throw (new Error("sysinfo error: " + stderr.toString()));
    }

    // output of sysinfo is a JSON object
    var sysinfo = JSON.parse(stdout);

    // Use the UUID param to uniquely identify this machine on AMQP.
    nodeUUID = sysinfo['UUID'];
    if (!nodeUUID) {
      throw new Error("Could not find 'UUID' in `sysinfo` output.");
    }

    self.uuid = nodeUUID;
    callback && callback();
  });
}

// Run the sysinfo script and return the captured stdout, stderr, and exit
// status code.
function loadSysinfo (callback) {
  execFile
    ( '/usr/bin/sysinfo'
    , []
    , function (exitStatus, stdout, stderr) {
        if (exitStatus)
          return callback(new Error(stderr), exitStatus, stdout, stderr);
       
        callback
          ( undefined
          , exitStatus
          , stdout.toString().trim()
          , stderr.toString().trim()
          );
        return;
      }
    );
} 

AMQPAgent.prototype.connect = function(callback) {
  var self = this;

  self.lookupUUID(function () {
    var cb = function () {
      self.setupQueue(function () {
        callback();
      });
    }

    self.configureAMQP(function () {
      console.log("Connection details:", inspect(self.config.amqp));
      self.connection = amqp.createConnection(self.config.amqp);
      self.addListeners(cb);
    })
  });
}

AMQPAgent.prototype.end = function () {
  this.connection.end();
}

AMQPAgent.prototype.addListeners = function (callback) {
  var self = this;

  var once = [callback];
  this.connection.addListener('ready', function () {
    console.log("Ready to receive commands");
    self.exchange = self.connection.exchange('amq.topic', { type: 'topic' });

    // Call callback on first connect, but not on reconnect.
    if (once.length)
      once.pop()();
  });

  this.connection.addListener('error', function (e) {
    console.log("There was an AMQP error: " + e.message);
  });

  this.connection.addListener('close', function () {
    if (self.config.reconnect) {
      console.log('MQ connection severed. Waiting 5 seconds...');
      setTimeout(function () {
        console.log('Connecting...');
        self.connection.reconnect();
      }, 5000);
    }
  });
}

//  Reply to client with an ACK message indicating command success
AMQPAgent.prototype.ackSuccess = function (id, data) {
  this._done = true;
  var msg = { req_id: id
            , timestamp: timestamp()
            };
  if (data && Object.keys(data).length) {
    for (key in data) {
      msg[key] = data[key];
    }
  }

  console.log("Publishing success: " + inspect(msg));
  this.exchange.publish
    ( this.config.resource
      + '.ack'
      + this.messageIdToClientId[id]
      + '.'
      + this.uuid
    , msg
    );

  if (!this.gracefulStop) {
    this.queue.shift();
  }
}

//  Reply to client with an ACK message indicating command error
AMQPAgent.prototype.ackError = function (id, error) {
  this._done = true;
  var msg = { req_id: id
            , timestamp: timestamp()
            , error: error };
  console.log("Publishing error " + inspect(msg));
  this.exchange.publish
    ( this.config.resource
      + '.ack'
      + this.messageIdToClientId[id]
      + '.'
      + this.uuid
    , msg);

  if (!this.gracefulStop) {
    this.queue.shift();
  }
}

AMQPAgent.prototype.stopShifting = function () {
  this.gracefulStop = true;
}

AMQPAgent.prototype.isDone = function () {
  return this._done;
}

AMQPAgent.prototype.handleMessage = function(msg) {
  var self = this;
  if (!msg._routingKey) {
    log('Error: message received without routingKey:\n' + inspect(msg));
    return;
  }

  var command = msg._routingKey.split('.')[1];

  if (this.commandNames.indexOf(command) === -1) {
    var errorMsg = 'Error: message received with invalid command, "'
                   + command + '"';
    self.ackError(msg.id, errorMsg);
    return;
  }

  console.log("--- Message received:\n" + inspect(msg));

  this.messageIdToClientId[msg.id] = msg.client_id;
  this._done = false;
  this.emit('command', command, msg);
}

AMQPAgent.prototype.registerCommand = function (command) {
  this.commandNames.push(command);
}

AMQPAgent.prototype.setupQueue = function(callback) {
  var self = this;
  var queueName = this.queueName = this.config.resource + '.' + this.uuid;
  this.queue = this.connection.queue(queueName);

  for (var i = 0, il = this.commandNames.length; i < il; i++) {
    self.queue.bind('amq.topic', this.config.resource + '.' + this.commandNames[i] + '.' + this.uuid);
  }
  this.queue.addListener('open', function (messageCount, consumerCount) {
    self.queue.subscribeJSON({ ack: true }, function (msg) {
      self.handleMessage(msg);
      // We will let ackError/ackSuccess do queue shifting
    });
  });

  callback();
}

