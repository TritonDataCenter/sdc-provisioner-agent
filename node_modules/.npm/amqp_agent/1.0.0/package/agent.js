sys = require('sys');
dns = require('dns');

amqp = require('amqp');
mDNS = require('mdns');
dns = require('dns');
exec = require('child_process').exec;

EventEmitter = require("events").EventEmitter;

inspect = sys.inspect;
puts = sys.puts;

exports.timestamp = timestamp = function () { return (new Date).toISOString(); }

exports.AMQPAgent = AMQPAgent = function (config) {
  var self = this;
  EventEmitter.call(this);

  this.config = config = config || { amqp: {} };
  this.commandNames = [];

  // AMQP credentials
  this.config.amqp = this.config.amqp || {};
  this.config.amqp.host
    = config.amqp.host     || process.env['AMQP_HOST']      || 'localhost';
  this.config.amqp.login
    = config.amqp.login    || process.env['AMQP_LOGIN']     || 'guest';
  this.config.amqp.password
    = config.amqp.password || process.env['AMQP_PASSWORD']  || 'guest';
  this.config.amqp.vhost
    = config.amqp.vhost    || process.env['AMQP_VHOST']     || '/';
  this.config.amqp.port
    = config.amqp.port     || process.env['AMQP_PORT']     || 5672;

  // Map the id's of incoming messages to the clients who sent them. This is
  // to avoid spamming all clients with ACKs they don't care about.
  this.messageIdToClientId = {};
}

sys.inherits(AMQPAgent, EventEmitter);

AMQPAgent.prototype.determineHostname = function (callback) {
  var self = this;
  puts("Determining agent's hostname");
  if (!self.config.hostname) {
    // look up the hostname
    exec('hostname', function (err, out) {
      if (err) throw err;

      // de-FQDN the hostname
      // foo123 => foo123
      // foo123.bar.baz.com => foo123
      var hostname = out.trim();
      var dot = hostname.indexOf('.');
      if (dot !== -1) hostname = hostname.slice(0, dot);

      self.hostname = hostname;
      callback && callback();
    });
    return;
  }
  else {
    self.hostname = self.config.hostname;
    callback && callback();
  }
}

AMQPAgent.prototype.connect = function(callback) {
  var self = this;

  self.determineHostname(function () {
    var cb = function () {
      self.setupQueue(function () {
        callback();
      });
    }

    puts("Connection details:", inspect(self.config.amqp));
    if (self.config.mdns) {
      self.mDNSConnect(cb);
    }
    else {
      self.connection = amqp.createConnection(self.config.amqp);
      self.addListeners(cb);
    }
  });
}

AMQPAgent.prototype.mDNSConnect = function (callback) {
  var self = this;

  puts("Looking '" + this.config.mdns + "' service in mDNS.");
  var browser = mDNS.createBrowser(this.config.mdns, { resolveAddress: false, autoResolve: true });

  receivedResponse = false;
  browser.addListener('serviceUp', function(info) {
    if (receivedResponse) return;
    receivedResponse = true;

    browser.stop();
    puts('Received mDNS serviceUp event for "' + self.config.mdns + '": ', inspect(info));

    self.config.amqp.port = info['port'];
    dns.lookup(info['host'].replace(/\.$/, ''), function (error, addr) {
      if (error) throw error;
      self.config.amqp.host = addr;
      self.connection = amqp.createConnection(self.config.amqp);
      self.addListeners(callback);
    });
  });
  browser.start();
}

AMQPAgent.prototype.end = function () {
  this.connection.end();
}

AMQPAgent.prototype.addListeners = function (callback) {
  var self = this;

  var once = [callback];
  this.connection.addListener('ready', function () {
    // grab and use the hostname to create our routing key

    puts("Ready to receive commands");
    self.exchange = self.connection.exchange('amq.topic', { type: 'topic' });

    // Call callback on first connect, but not on reconnect.
    if (once.length)
      once.pop()();
  });

  this.connection.addListener('error', function (e) {
    puts("There was an AMQP error: " + e.message);
  });

  this.connection.addListener('close', function () {
    if (self.config.reconnect) {
      puts('MQ connection severed. Waiting 5 seconds...');
      setTimeout(function () {
        puts('Connecting...');
        self.connection.reconnect();
      }, 5000);
    }
  });
}

//  Reply to client with an ACK message indicating command success
AMQPAgent.prototype.ackSuccess = function (id, data) {
  var msg = { req_id: id
            , timestamp: timestamp() };
  if (data && Object.keys(data).length) {
    for (key in data) {
      msg[key] = data[key];
    }
  }
  puts("Publishing success: " + inspect(msg));
  this.exchange.publish(this.config.resource + '.ack' + this.messageIdToClientId[id]
                        + '.' + this.hostname, msg);
  this.queue.shift();
}

//  Reply to client with an ACK message indicating command error
AMQPAgent.prototype.ackError = function (id, error) {
  var msg = { req_id: id
            , timestamp: timestamp()
            , error: error };
  puts("Publishing error " + inspect(msg));
  this.exchange.publish(this.config.resource + '.ack'  + this.messageIdToClientId[id]
                        + '.' + this.hostname, msg);
  this.queue.shift();
}

AMQPAgent.prototype.handleMessage = function(msg) {
  var self = this;
  if (!msg._routingKey) {
    log('Error: message received without routingKey:\n' + inspect(msg));
    return;
  }

  var command = msg._routingKey.split('.')[1];

  if (this.commandNames.indexOf(command) === -1) {
    self.ackError(msg.id, 'Error: message received with invalid command, "' + command + '"');
    return;
  }

  puts("--- Message received:\n" + inspect(msg));

  this.messageIdToClientId[msg.id] = msg.client_id;
  this.emit('command', command, msg);
}

AMQPAgent.prototype.registerCommand = function (command) {
  this.commandNames.push(command);
}

AMQPAgent.prototype.setupQueue = function(callback) {
  var self = this;
  var queueName = this.queueName = this.config.resource + '.' + this.hostname;
  this.queue = this.connection.queue(queueName, { exclusive: true });

  for (var i = 0, il = this.commandNames.length; i < il; i++) {
    self.queue.bind('amq.topic', this.config.resource + '.' + this.commandNames[i] + '.' + this.hostname);
  }
  this.queue.addListener('open', function (messageCount, consumerCount) {
    self.queue.subscribeJSON({ ack: true }, function (msg) {
      self.handleMessage(msg);
      // We will let ackError/ackSuccess do queue shifting
    });
  });

  callback();
}

